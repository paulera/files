#!/usr/bin/env python3
# AI-MADE
# https://chatgpt.com/share/68652076-c23c-800f-9cc5-cfff4a7a1616
"""
Simple CLI tool to run JQL queries against a Jira instance and display results in an ASCII table with optional field wrapping/truncation,
or raw output for scripting, or list and cache available JQL fields for alias mapping.
Cached alias mappings are stored in ~/.jql_config.json under the "fields_map" key.

Usage:
  jql [-f fields] [-r|--raw] [-s SEP] [-n LIMIT] [-T TABLEFMT] \
      [--list-fields [all|jira|custom|update]] <JQL query>

Fields syntax:
  Fields comma-separated; wrap with () or truncate with {}:
    summary(40),status,priority{10},cf[10162]
  - wrap: parentheses, truncate: curly braces
  - cf[n]: customfield_n via regex, not stored in cache

Options:
  -f, --fields      Fields list (default: key,issuetype,priority,status,summary,assignee)
  -r, --raw         Raw output: values separated by SEP
  -s, --sep SEP     Raw field separator (default: "|")
  -n, --limit LIMIT Max issues to fetch (default:100; -1 for all)
  -T, --tablefmt TF Table format (tabulate; default:"simple_grid")
  --list-fields [all|jira|custom|update]
                     List fields (all/jira/custom) or update cache
  -h, --help        Show help and exit
"""
import os
import sys
import json
import argparse
import requests
import re
import textwrap
from requests.auth import HTTPBasicAuth
from tabulate import tabulate

CONFIG_PATH = os.path.expanduser('~/.jql_config.json')
CF_RE = re.compile(r'^cf\[(\d+)\]$')


def fetch_issues(url, auth, params, limit):
    issues, start = [], 0
    page = 100 if limit < 0 else min(limit, 100)
    while True:
        params.update(startAt=start, maxResults=page)
        r = requests.get(url, auth=auth, params=params)
        if r.status_code != 200:
            sys.exit(f"Error: {r.status_code} {r.text}")
        batch = r.json().get('issues', [])
        if not batch:
            break
        issues.extend(batch)
        if 0 <= limit <= len(issues):
            issues = issues[:limit]
            break
        if len(batch) < page:
            break
        start += page
    return issues


def extract_text(node):
    if isinstance(node, dict):
        if node.get('type') == 'text':
            return node.get('text', '')
        return ''.join(extract_text(c) for c in node.get('content', []))
    if isinstance(node, list):
        return ''.join(extract_text(i) for i in node)
    return ''


def fetch_and_build_map(api, auth):
    r = requests.get(f"{api}/rest/api/3/field", auth=auth)
    if r.status_code != 200:
        sys.exit(f"Error fetching fields: {r.status_code}")
    alias_map = {}
    for f in r.json():
        fid, name = f['id'], f['name']
        alias_map[name] = fid
        for c in f.get('clauseNames', []) or []:
            alias_map[c] = fid
    # Remove any cf[...] entries if present (not persisted)
    alias_map = {k: v for k, v in alias_map.items() if not CF_RE.match(k)}
    with open(CONFIG_PATH, 'w') as fp:
        json.dump({'fields_map': alias_map}, fp)
    print(f"Cache updated: {len(alias_map)} aliases stored under 'fields_map'")
    sys.exit(0)


def load_map():
    if not os.path.exists(CONFIG_PATH):
        return {}
    try:
        cfg = json.load(open(CONFIG_PATH))
        return cfg.get('fields_map', {})
    except:
        return {}


def list_fields(api, auth, cat):
    r = requests.get(f"{api}/rest/api/3/field", auth=auth)
    if r.status_code != 200:
        sys.exit("Error listing fields")
    fields = r.json()
    if cat == 'jira':
        fields = [f for f in fields if not f['id'].startswith('customfield_')]
    elif cat == 'custom':
        fields = [f for f in fields if f['id'].startswith('customfield_')]
    for f in sorted(fields, key=lambda x: x['name'].lower()):
        fid, name = f['id'], f['name']
        if fid.startswith('customfield_'):
            num = fid.split('_', 1)[1]
            fid = f'cf[{num}]'
        print(f"{name}:{fid}")
    sys.exit(0)


def main():
    api = os.getenv('JIRA_URL', '').rstrip('/')
    auth = HTTPBasicAuth(os.getenv('JIRA_USER', ''), os.getenv('JIRA_API_TOKEN', ''))
    parser = argparse.ArgumentParser(
        formatter_class=argparse.RawDescriptionHelpFormatter,
        description=__doc__
    )
    parser.add_argument('-f', '--fields', default='key,issuetype,priority,status,summary,assignee')
    parser.add_argument('-r', '--raw', action='store_true')
    parser.add_argument('-s', '--sep', default='|')
    parser.add_argument('-n', '--limit', type=int, default=100)
    parser.add_argument('-T', '--tablefmt', default='simple_grid')
    parser.add_argument('--list-fields', nargs='?', const='all',
                        choices=['all', 'jira', 'custom', 'update'])
    parser.add_argument('jql', nargs='*')
    args = parser.parse_args()

    if args.list_fields:
        if args.list_fields == 'update':
            fetch_and_build_map(api, auth)
        list_fields(api, auth, args.list_fields)

    if not args.jql:
        parser.error('JQL query required')

    amap = load_map()
    if not amap:
        print("Cache missing or empty, updating...")
        fetch_and_build_map(api, auth)

    specs = []
    for item in args.fields.split(','):
        spec = item.strip()
        wrap = None
        trunc = None
        m1 = re.match(r'^(.+?)\((\d+)\)$', spec)
        m2 = re.match(r'^(.+?)\{(\d+)\}$', spec)
        if m1:
            alias, wrap = m1.group(1), int(m1.group(2))
        elif m2:
            alias, trunc = m2.group(1), int(m2.group(2))
        else:
            alias = spec
        mcf = CF_RE.match(alias)
        if mcf:
            real = f"customfield_{mcf.group(1)}"
        else:
            real = amap.get(alias, alias)
        display = alias if alias == 'issuekey' or alias == 'key' else next(
            (k for k, v in amap.items() if v == real), alias
        )
        specs.append((real, wrap, trunc, display))

    url = f"{api}/rest/api/3/search"
    params = {'jql': ' '.join(args.jql), 'fields': ','.join(s[0] for s in specs)}
    issues = fetch_issues(url, auth, params, args.limit)
    if not issues:
        print("No issues found.")
        return

    raw_rows = []
    vis_rows = []
    for issue in issues:
        rowr, rowv = [], []
        data = issue.get('fields', {})
        for real, wrap, trunc, disp in specs:
            if real == 'issuekey':
                val = issue.get('key', '')
            else:
                x = data.get(real, '')
                if isinstance(x, dict):
                    if x.get('type') == 'doc':
                        val = extract_text(x)
                    else:
                        val = x.get('value', x.get('name', str(x)))
                elif isinstance(x, list):
                    parts = []
                    for it in x:
                        if isinstance(it, dict):
                            if it.get('type') == 'doc':
                                parts.append(extract_text(it))
                            else:
                                parts.append(it.get('value', it.get('name', str(it))))
                        else:
                            parts.append(str(it))
                    val = ','.join(parts)
                else:
                    val = str(x)
            val = val.strip()
            rowr.append(val)
            if wrap is not None:
                rowv.append(textwrap.fill(val, width=wrap))
            elif trunc is not None:
                rowv.append(val[:trunc].strip())
            else:
                rowv.append(val)
        raw_rows.append(rowr)
        vis_rows.append(rowv)

    if args.raw:
        for r in raw_rows:
            print(args.sep.join(r))
    else:
        print(f"\n\033[1;33m{' '.join(args.jql)}\033[0m")
        print(f"\033[1;37m{len(issues)} rows\033[0m\n")
        headers = [f"\033[1;37m{d}\033[0m" for *_, d in specs]
        print(tabulate(vis_rows, headers=headers, tablefmt=args.tablefmt))

if __name__ == '__main__':
    main()
