#!/usr/bin/env python3
# AI-MADE
# https://chatgpt.com/share/68652076-c23c-800f-9cc5-cfff4a7a1616
"""
Simple CLI tool to run JQL queries against a Jira instance and display results in an ASCII table with optional field wrapping/truncation,
or raw output for scripting, or list available JQL fields.

Usage:
  jql [-f fields] [-r|--raw] [-s SEP] [-n LIMIT] [-T TABLEFMT] [--list-fields [all|jira|custom]] <JQL query>

Fields syntax:
  Specify fields as comma-separated names, with optional wrapping (parentheses) or truncation (square brackets):
    summary(40),status,priority[10]
  - summary(40) wraps at 40 chars
  - priority[10] truncates to 10 chars
  - status with no spec is unmodified

Environment variables:
  JIRA_API_TOKEN  - your Jira API token
  JIRA_URL        - the base URL of your Jira instance (e.g. https://your-domain.atlassian.net)
  JIRA_USER       - your Jira user/email (for Basic auth)

Modes:
  Visual (default): ASCII table, honoring per-field wrap/truncate widths, shows the JQL query in yellow above the table with bright-white headers, and the resulting row count below
  Raw (-r, --raw): each record as field values separated by SEP (default "|")
  List Fields (--list-fields): list JQL fields then exit
    optional value: all (default), jira (only native fields), custom (only custom fields)

Options:
  -f, --fields      Fields list, e.g. issuekey,summary(50),status,priority[10]
  -r, --raw         Raw output mode: only field values separated by SEP
  -s SEP, --sep SEP Field separator for raw mode (default: "|")
  -n LIMIT, --limit LIMIT
                     Maximum number of issues to return (default: 100; -1 for all)
  -T TABLEFMT, --tablefmt TABLEFMT
                     Table format for visual mode (tabulate tablefmt; default: "simple_grid")
  --list-fields [all|jira|custom]
                     List fields (all/jira/custom) and exit
  -h, --help        Show this help message and exit
"""
import os
import sys
import argparse
import requests
import re
import textwrap
from requests.auth import HTTPBasicAuth
from tabulate import tabulate


def fetch_issues(api_endpoint, auth, params, limit):
    issues = []
    start_at = 0
    page_size = 100 if limit < 0 else min(limit, 100)
    while True:
        params.update({'startAt': start_at, 'maxResults': page_size})
        resp = requests.get(api_endpoint, auth=auth, params=params)
        if resp.status_code != 200:
            sys.stderr.write(f"Error: Jira API returned {resp.status_code}: {resp.text}\n")
            sys.exit(1)
        data = resp.json()
        batch = data.get('issues', [])
        if not batch:
            break
        issues.extend(batch)
        if limit > 0 and len(issues) >= limit:
            issues = issues[:limit]
            break
        if len(batch) < page_size:
            break
        start_at += page_size
    return issues


def list_fields(api_endpoint, auth, category):
    # Use API v3 to list fields
    resp = requests.get(f"{api_endpoint.rstrip('/')}/rest/api/3/field", auth=auth)
    if resp.status_code != 200:
        sys.stderr.write(f"Error listing fields: {resp.status_code}: {resp.text}\n")
        sys.exit(1)
    fields = resp.json()
    # Filter by category
    if category == 'jira':
        fields = [f for f in fields if not f.get('id', '').startswith('customfield_')]
    elif category == 'custom':
        fields = [f for f in fields if f.get('id', '').startswith('customfield_')]
    # Sort alphabetically by display name
    fields.sort(key=lambda f: f.get('name', '').lower())
    for field in fields:
        print(f"{field.get('name')}:{field.get('id')}")
    sys.exit(0)


def main():
    jira_url = os.getenv('JIRA_URL')
    api_token = os.getenv('JIRA_API_TOKEN')
    user = os.getenv('JIRA_USER')
    if not jira_url or not api_token or not user:
        sys.stderr.write(
            "Error: JIRA_URL, JIRA_API_TOKEN, and JIRA_USER environment variables must all be set.\n"
        )
        sys.exit(1)

    default_fields = ["issuekey", "type", "priority", "status", "summary"]
    parser = argparse.ArgumentParser(
        prog='jql',
        description='Run a JQL query against Jira or list fields.',
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog=__doc__
    )
    parser.add_argument(
        '-f', '--fields',
        help='Fields list, e.g. issuekey,summary(50),status,priority[10]',
        default=','.join(default_fields)
    )
    parser.add_argument(
        '-r', '--raw',
        action='store_true',
        help='Raw output mode: only field values separated by SEP'
    )
    parser.add_argument(
        '-s', '--sep',
        help='Field separator for raw mode (default: "|")',
        default='|'
    )
    parser.add_argument(
        '-n', '--limit',
        type=int,
        help='Maximum number of issues to return (default: 100; -1 for all)',
        default=100
    )
    parser.add_argument(
        '-T', '--tablefmt',
        help='Table format for visual mode (tabulate tablefmt; default: "simple_grid")',
        default='simple_grid'
    )
    parser.add_argument(
        '--list-fields',
        nargs='?',
        const='all',
        choices=['all', 'jira', 'custom'],
        help='List fields (all/jira/custom) and exit'
    )
    parser.add_argument(
        'jql',
        nargs='*',
        help='The JQL query to execute (wrap in quotes if it contains spaces)'
    )
    args = parser.parse_args()

    auth = HTTPBasicAuth(user, api_token)

    if args.list_fields is not None:
        list_fields(jira_url, auth, args.list_fields)

    if not args.jql:
        parser.error('A JQL query is required unless --list-fields is used')

    # Parse fields with optional wrap/truncate
    field_specs = []
    for spec in args.fields.split(','):
        s = spec.strip()
        wrap = truncate = None
        m_wrap = re.match(r'^(.+?)\((\d+)\)$', s)
        m_trunc = re.match(r'^(.+?)\[(\d+)\]$', s)
        if m_wrap:
            name = m_wrap.group(1)
            wrap = int(m_wrap.group(2))
        elif m_trunc:
            name = m_trunc.group(1)
            truncate = int(m_trunc.group(2))
        else:
            name = s
        field_specs.append((name, wrap, truncate))
    field_names = [fs[0] for fs in field_specs]

    # Build JQL search
    jql_query = ' '.join(args.jql)
    api_search = f"{jira_url.rstrip('/')}/rest/api/3/search"
    params = {
        'jql': jql_query,
        'fields': ','.join(['issuetype' if f.lower() == 'type' else f for f in field_names])
    }

    issues = fetch_issues(api_search, auth, params, args.limit)
    if not issues:
        print("No issues found.")
        return

    raw_rows = []
    visual_rows = []
    for issue in issues:
        raw_row = []
        vis_row = []
        fields = issue.get('fields', {})
        for name, wrap_width, trunc_width in field_specs:
            key = name.lower()
            if key == 'issuekey':
                val = issue.get('key', '')
            elif key == 'type':
                val = fields.get('issuetype', {}).get('name', '')
            elif key == 'status':
                val = fields.get('status', {}).get('name', '')
            elif key == 'priority':
                val = fields.get('priority', {}).get('name', '')
            else:
                raw_data = fields.get(name, '')
                if isinstance(raw_data, dict) and 'name' in raw_data:
                    val = raw_data['name']
                else:
                    val = str(raw_data)
            raw_row.append(val)
            if wrap_width:
                vis_val = textwrap.fill(val, width=wrap_width)
            elif trunc_width is not None:
                vis_val = val[:trunc_width]
            else:
                vis_val = val
            vis_row.append(vis_val)
        raw_rows.append(raw_row)
        visual_rows.append(vis_row)

    if args.raw:
        for row in raw_rows:
            print(args.sep.join(row))
    else:
        # Show query in yellow
        print(f"\n\033[1;33m{jql_query}\033[0m")
        print(f"\033[1;37m{len(issues)} rows\033[0m\n")
        # Bright-white headers
        colored_headers = [f"\033[1;37m{h}\033[0m" for h in field_names]
        print(tabulate(visual_rows, headers=colored_headers, tablefmt=args.tablefmt))


if __name__ == '__main__':
    main()

